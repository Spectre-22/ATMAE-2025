#pragma config(Sensor, in1,    lineFollowerRIGHT, sensorLineFollower)
#pragma config(Sensor, in2,    lineFollowerCENTER, sensorLineFollower)
#pragma config(Sensor, in3,    lineFollowerLEFT, sensorLineFollower)
#pragma config(Sensor, dgtl6,  eStop,          sensorTouch)
#pragma config(Motor,  port3,           leftMotor,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           small_motor,   tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port5,           rightMotor,    tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port6,           left2M,        tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port7,           right2M,       tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port8,           rightArmServo, tmotorServoStandard, openLoop)
#pragma config(Motor,  port9,           leftArmServo,  tmotorServoStandard, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*----------------------------------------------------------------------------------------------------*\
|*                           - Arcade Joystick Control with Arm - 1 Remote -                          *|
|*                                      ROBOTC on VEX 2.0 Cortex                                      *|
|*                                                                                                    *|
|*  This program uses left stick to go forwards and backwards and the right stick to turn, called.    *|
|*  This is known as arcade drive.                                                                    *|
|*  The Group 6 buttons on the top-right of the VEXnet Joystick are used to raise and lower an arm.   *|
|*                                                                                                    *|
|*                                        ROBOT CONFIGURATION                                         *|
|*    NOTES:                                                                                          *|
|*    1)  To go forward/backward use the left joystick                                                *|
|*    2)  To turn, use the right joystick                                                             *|
|*                                                                                                    *|
|*    MOTORS & SENSORS:                                                                               *|
|*    [I/O Port]              [Name]              [Type]              [Description]                   *|
|*    Motor - Port 3          leftMotor            Rev Motor           Left motor                     *|
|*    Motor - Port 4          small_motor          Vex Motor           arm                            *|
|*    Motor - Port 5          rightMotor           Rev Motor           Right motor                    *|
|*    Motor - Port 6          left2M               Rev Motor           2nd Left Motor                 *|
|*    Motor - Port 7          right2M              Rev Motor           2nd Right Motor                *|
|*    Servo - Port 8          rightArmServo        Futaba Servo          Servo                        *|
|*    Servo - Port 9          leftArmServo         Futaba Servo          Servo                        */
/*----------------------------------------------------------------------------------------------------*/


	void motorBack()
	{
		motor[small_motor] = -100;
		wait1Msec(500);
	}
	void motorForward()
	{
		motor[small_motor] = 100;
		wait1Msec(500);
	}
	void motorStop()
	{
		motor[small_motor] = 0;
		wait1Msec(100);
	}
void EStop()
	{
		motor[rightMotor] = 0;
		motor[right2M] = 0;
		motor[leftMotor] = 0;
		motor[left2M] = 0;
		motor[small_motor] = 0;
		motor[rightArmServo] = 127;
    motor[leftArmServo] = 127;
    while (true)
	{
		wait1Msec(100);
	}
}
	
	void ServoOpen()
{
	// Adjust as needed for your servo open position
	motor[rightArmServo] = 127;
	motor[leftArmServo] = 127;
}

void ServoClose()
{
	// Adjust as needed for your servo closed position
	motor[rightArmServo] = -127;
	motor[leftArmServo] = -127;
}

//+++++++++++++++++++++++++++++++++++++++++++++| MAIN |+++++++++++++++++++++++++++++++++++++++++++++++
//====================| TASK AUTONOMOUS |============================================
task autonomous()
{
  // Drive all motors forward at full speed
  motor[leftMotor]  = 127;
  motor[left2M]     = 127;
  motor[rightMotor] = 127;
  motor[right2M]    = 127;

  // Run for 1 second (1000 milliseconds)
  wait1Msec(1000);

  // Stop all motors
  motor[leftMotor]  = 0;
  motor[left2M]     = 0;
  motor[rightMotor] = 0;
  motor[right2M]    = 0;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
task main()
{
  while(true)
  {
    // DriveTrain time
    int power = vexRT[Ch3];
    int turn = vexRT[Ch1];

     // Motor speed calculations
    int leftSpeed = power + turn;
    int rightSpeed = power - turn;

    // Default to half speed
    leftSpeed /= 2;
    rightSpeed /= 2;

    // If Btn8L is held, use full speed
    if(vexRT[Btn5U] == 1)
    {
        leftSpeed  *= 2;
        rightSpeed *= 2;
    }

    // Now assign final motor speeds
    motor[leftMotor]  = leftSpeed;
    motor[left2M]     = leftSpeed;
    motor[rightMotor] = rightSpeed;
    motor[right2M]    = rightSpeed;

    //Autonomous mode trigger (Btn8R)
    if (vexRT[Btn8R] == 1 && vexRT[Btn7L] == 1)
    {
    	startTask(autonomous);
    }

    // Motor forward/backward (assuming these are custom functions)
    if(vexRT[Btn6D] == 1)
    {
      motorForward();
    }
    else if(vexRT[Btn6U] == 1)
    {
      motorBack();
    }
    else
    {
      motorStop();  // Stop small_motor if neither is pressed
    }

    // Servo control
    if (vexRT[Btn8U])
    {
      ServoOpen();
    }
    if (vexRT[Btn8D])
    {
      ServoClose();
    }

    // Emergency stop
    if (SensorValue[eStop] == 0)
    {
      EStop();
    }

    // Prevent CPU overload
    wait1Msec(20);
  }
}